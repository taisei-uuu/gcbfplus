# DoubleIntegrator環境へのバックステッピング制御実装ガイド

## 1. 論文の背景理解

GCBFフレームワークは、マルチエージェントシステムの安全性を保証するために、**グラフ制御バリア関数（GCBF）**を使用しています。論文ではDoubleIntegrator環境に対して、以下の特性を持つ制御を提案しています：

- **安全性**：障害物との衝突回避
- **到達性**：目標位置への到達
- **スケーラビリティ**：エージェント数に関わらず動作

## 2. DoubleIntegrator環境の基本動力学

### 2.1 標準的なDoubleIntegrator動力学

DoubleIntegrator環境では、各エージェント $i$ の動力学は以下のように記述されます：

$$\dot{x}_i = v_i$$
$$\dot{v}_i = u_i$$

ここで：
- $x_i \in \mathbb{R}^n$：エージェント $i$ の位置
- $v_i \in \mathbb{R}^n$：エージェント $i$ の速度
- $u_i \in \mathbb{R}^n$：エージェント $i$ の加速度（制御入力）

### 2.2 状態ベクトルの定義

全体システムの状態は以下のように定義されます：

$$\mathbf{x} = [x_1, v_1, x_2, v_2, \ldots, x_N, v_N]^T \in \mathbb{R}^{2nN}$$

## 3. バックステッピング制御の基本原理

バックステッピングは、**Lyapunov安定性理論**に基づいた非線形制御設計手法です。DoubleIntegrator系では、以下のように段階的に制御則を設計します。

### 3.1 第1段階：位置制御則の設計

目標位置を $p_i^d$ とします。位置誤差を定義します：

$$e_{p,i} = x_i - p_i^d$$

Lyapunov関数の候補を以下のように設定します：

$$V_1 = \frac{1}{2} e_{p,i}^T e_{p,i}$$

時間微分を計算すると：

$$\dot{V}_1 = e_{p,i}^T \dot{e}_{p,i} = e_{p,i}^T (v_i - \dot{p}_i^d)$$

安定性を保証するために、**仮想的な速度参照値** $v_{i,ref}$ を以下のように設定します：

$$v_{i,ref} = -k_p e_{p,i} + \dot{p}_i^d$$

ここで $k_p > 0$ は位置ゲインです。

### 3.2 第2段階：速度制御則の設計

速度誤差を定義します：

$$e_{v,i} = v_i - v_{i,ref}$$

拡張Lyapunov関数を設定します：

$$V_2 = V_1 + \frac{1}{2} e_{v,i}^T e_{v,i}$$

時間微分を計算すると：

$$\dot{V}_2 = e_{p,i}^T (v_i - \dot{p}_i^d) + e_{v,i}^T (\dot{v}_i - \dot{v}_{i,ref})$$

$v_i = e_{v,i} + v_{i,ref}$ を代入すると：

$$\dot{V}_2 = e_{p,i}^T e_{v,i} + e_{v,i}^T (u_i - \dot{v}_{i,ref})$$

安定性を保証するために、制御入力を以下のように設定します：

$$u_i = -k_v e_{v,i} - e_{p,i} + \dot{v}_{i,ref}$$

ここで $k_v > 0$ は速度ゲインです。

### 3.3 安定性の検証

上記の制御則を代入すると：

$$\dot{V}_2 = -k_v e_{v,i}^T e_{v,i} \leq 0$$

これにより、Lyapunov安定性が保証されます。

## 4. 動的目標への拡張

### 4.1 動的目標の定義

目標位置が時間に依存する場合、目標軌跡を $p_i^d(t)$ とします。目標の速度と加速度も定義します：

$$v_i^d(t) = \dot{p}_i^d(t)$$
$$a_i^d(t) = \ddot{p}_i^d(t)$$

### 4.2 修正されたバックステッピング制御則

動的目標に対応するために、第1段階の仮想速度参照値を以下のように修正します：

$$v_{i,ref} = -k_p e_{p,i} + v_i^d$$

第2段階の制御入力を以下のように修正します：

$$u_i = -k_v e_{v,i} - e_{p,i} + a_i^d$$

### 4.3 安定性の再検証

修正されたLyapunov関数の時間微分：

$$\dot{V}_2 = e_{p,i}^T (v_i - v_i^d) + e_{v,i}^T (u_i - a_i^d)$$

制御則を代入すると：

$$\dot{V}_2 = e_{p,i}^T e_{v,i} + e_{v,i}^T (-k_v e_{v,i} - e_{p,i})$$
$$= -k_v e_{v,i}^T e_{v,i} \leq 0$$

安定性が保証されます。

## 5. GCBF制約との統合

### 5.1 制御バリア関数の制約

GCBFから得られる制約条件は以下の形式です：

$$\frac{\partial h}{\partial x_i} (f_i(x_i) + g_i(x_i) u_i) + \alpha(h(x_i)) \geq 0$$

ここで $h(x_i)$ はバリア関数です。

### 5.2 制約付きバックステッピング制御

バックステッピング制御とGCBF制約を統合するために、**二次計画法（QP）** を使用します：

$$\min_{u_i} \|u_i - u_i^{bs}\|^2$$

制約条件：
$$\frac{\partial h}{\partial x_i} (f_i(x_i) + g_i(x_i) u_i) + \alpha(h(x_i)) \geq 0$$
$$u_i \in \mathcal{U}$$

ここで $u_i^{bs}$ はバックステッピング制御則から得られた理想的な制御入力です。

## 6. DoubleIntegrator環境での具体的な実装

### 6.1 DoubleIntegrator用のバリア関数

DoubleIntegrator環境では、以下のバリア関数を使用します：

$$h_i(x_i) = \min_{j \in \mathcal{N}_i} \left( \|x_i - x_j\|^2 - (2r)^2 \right)$$

ここで $r$ は安全半径です。

### 6.2 バリア関数の勾配

バリア関数の勾配は：

$$\frac{\partial h_i}{\partial x_i} = 2(x_i - x_j^*) \quad \text{（最も近いエージェント } j^* \text{ に対して）}$$

### 6.3 制御入力の計算

DoubleIntegrator系では、制御入力は加速度 $u_i$ です。バックステッピング制御則は：

$$u_i^{bs} = -k_v (v_i - v_{i,ref}) - (x_i - p_i^d) + a_i^d$$

GCBF制約を満たすために、QP問題を解きます：

$$\min_{u_i} \|u_i - u_i^{bs}\|^2$$

制約条件：
$$2(x_i - x_j^*)^T (v_i + u_i \Delta t) + \alpha(h_i(x_i)) \geq 0$$

## 7. 数値実装のポイント

### 7.1 時間離散化

連続時間システムを離散時間で実装する場合：

$$x_i(k+1) = x_i(k) + v_i(k) \Delta t$$
$$v_i(k+1) = v_i(k) + u_i(k) \Delta t$$

### 7.2 ゲイン選択

バックステッピング制御のゲイン選択：
- $k_p$：位置誤差に対する応答性を制御
- $k_v$：速度誤差に対する減衰を制御

一般的には $k_p, k_v > 0$ で、$k_v > 2\sqrt{k_p}$ を満たすと安定性が向上します。

### 7.3 GCBF制約の緩和

実装上、GCBF制約が厳しすぎる場合、緩和パラメータ $\alpha$ を調整します：

$$\alpha(h) = \gamma h \quad (\gamma > 0)$$

$\gamma$ が大きいほど、制約がより強く適用されます。

## 8. 実装フロー

```
1. 初期化
   - エージェント位置、速度を設定
   - 目標軌跡 p_i^d(t), v_i^d(t), a_i^d(t) を定義
   - ゲイン k_p, k_v を設定

2. 各時間ステップで：
   a. 目標軌跡から v_i^d, a_i^d を取得
   b. バックステッピング制御則を計算
      u_i^{bs} = -k_v e_{v,i} - e_{p,i} + a_i^d
   c. GCBF制約を評価
   d. QP問題を解いて最終的な u_i を決定
   e. 状態を更新
      x_i(k+1) = x_i(k) + v_i(k) Δt
      v_i(k+1) = v_i(k) + u_i(k) Δt
```

## 9. 主な改善点

GCBFv0と比較した改善点：

1. **動的目標への対応**：目標の速度・加速度情報を活用
2. **バックステッピング統合**：段階的な制御則設計で安定性向上
3. **制約の柔軟性**：QP問題で安全性と性能のバランスを取得
4. **スケーラビリティ**：グラフ構造により大規模システムに対応

